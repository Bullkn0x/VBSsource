{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./guest-api/index.ts","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/uuid/lib/rng.js","webpack:///./node_modules/uuid/v4.js","webpack:///external \"crypto\"","webpack:///external \"electron\""],"names":[],"mappings":"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","file":"guest-api.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./guest-api/index.ts\");\n","/**\n * This script is injected into guest webviews and used by the app\n * to expose small pieces of functionality based on the guest content.\n */\n\nimport electron from 'electron';\nimport {\n  IGuestApiRequest,\n  IGuestApiResponse,\n  IGuestApiCallback\n} from '../app/services/guest-api';\nimport uuid from 'uuid/v4';\n\n(() => {\n  global.eval = function() {\n    throw new Error('Eval is disabled for security');\n  }\n\n  interface IRequest {\n    resolve: (val: any) => void;\n    reject: (val: any) => void;\n    callbacks: {\n      [callbackId: string]: Function;\n    };\n  }\n\n  const requests: {\n    [requestId: string]: IRequest;\n  } = {};\n\n  let ready: Function;\n  const readyPromise = new Promise<boolean>(resolve => {\n    ready = resolve;\n  });\n\n  electron.ipcRenderer.on(\n    'guestApiCallback',\n    (event: any, response: IGuestApiCallback) => {\n      // This window was likely reloaded and no longer cares about this callback.\n      if (!requests[response.requestId]) return;\n      requests[response.requestId].callbacks[response.callbackId](...response.args);\n    }\n  );\n\n  electron.ipcRenderer.on(\n    'guestApiResponse',\n    (event: any, response: IGuestApiResponse) => {\n      if (!requests[response.id]) return;\n\n      if (response.error) {\n        requests[response.id].reject(response.result);\n      } else {\n        requests[response.id].resolve(response.result);\n      }\n\n      // Delete the request object if there aren't any callbacks\n      // to avoid leaking too much memory.\n      if (Object.keys(requests[response.id].callbacks).length === 0) {\n        delete requests[response.id];\n      }\n    }\n  );\n\n  electron.ipcRenderer.on(\n    'guestApiReady',\n    () => ready()\n  );\n\n  const mainWindowContents = electron.remote.webContents.fromId(\n    electron.ipcRenderer.sendSync('getMainWindowWebContentsId')\n  );\n  const webContentsId = electron.remote.getCurrentWebContents().id;\n\n  /**\n   * Returns a proxy rooted at the given path\n   * @param path the current path\n   */\n  function getProxy(path: string[] = []): any {\n    return new Proxy(\n      () => {},\n      {\n        get(target, key) {\n          if (key === 'apiReady') {\n            return readyPromise;\n          }\n\n          return getProxy(path.concat([key.toString()]));\n        },\n\n        apply(target, thisArg, args: any[]) {\n          const requestId = uuid();\n          requests[requestId] = {\n            resolve: null,\n            reject: null,\n            callbacks: {}\n          };\n          const promise = new Promise((resolve, reject) => {\n            requests[requestId].resolve = resolve;\n            requests[requestId].reject = reject;\n          });\n          const mappedArgs = args.map(arg => {\n            if (typeof arg === 'function') {\n              const callbackId = uuid();\n\n              requests[requestId].callbacks[callbackId] = arg;\n\n              return {\n                __guestApiCallback: true,\n                id: callbackId\n              };\n            }\n\n            return arg;\n          });\n\n          const apiRequest: IGuestApiRequest = {\n            id: requestId,\n            webContentsId,\n            methodPath: path,\n            args: mappedArgs\n          };\n\n          mainWindowContents.send('guestApiRequest', apiRequest);\n\n          return promise;\n        }\n      }\n    );\n  }\n\n  global['streamlabsOBS'] = getProxy();\n})();\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is prett straight-forward - we use the crypto API.\n\nvar rb = require('crypto').randomBytes;\n\nfunction rng() {\n  return rb(16);\n};\n\nmodule.exports = rng;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","module.exports = require(\"crypto\");","module.exports = require(\"electron\");"],"sourceRoot":""}